"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Presentation = void 0;
const AnoncredsObject_1 = require("../AnoncredsObject");
const register_1 = require("../register");
const Credential_1 = require("./Credential");
const CredentialDefinition_1 = require("./CredentialDefinition");
const CredentialRevocationState_1 = require("./CredentialRevocationState");
const PresentationRequest_1 = require("./PresentationRequest");
const RevocationRegistryDefinition_1 = require("./RevocationRegistryDefinition");
const RevocationStatusList_1 = require("./RevocationStatusList");
const Schema_1 = require("./Schema");
const utils_1 = require("./utils");
class Presentation extends AnoncredsObject_1.AnoncredsObject {
    static create(options) {
        let presentationHandle;
        // Objects created within this method must be freed up
        const objectHandles = [];
        try {
            const presentationRequest = options.presentationRequest instanceof PresentationRequest_1.PresentationRequest
                ? options.presentationRequest.handle
                : (0, utils_1.pushToArray)(PresentationRequest_1.PresentationRequest.fromJson(options.presentationRequest).handle, objectHandles);
            presentationHandle = register_1.anoncreds.createPresentation({
                presentationRequest,
                credentials: options.credentials.map((item) => ({
                    credential: item.credential instanceof Credential_1.Credential
                        ? item.credential.handle
                        : (0, utils_1.pushToArray)(Credential_1.Credential.fromJson(item.credential).handle, objectHandles),
                    revocationState: item.revocationState instanceof CredentialRevocationState_1.CredentialRevocationState
                        ? item.revocationState.handle
                        : item.revocationState !== undefined
                            ? (0, utils_1.pushToArray)(CredentialRevocationState_1.CredentialRevocationState.fromJson(item.revocationState).handle, objectHandles)
                            : undefined,
                    timestamp: item.timestamp,
                })),
                credentialsProve: options.credentialsProve,
                selfAttest: options.selfAttest,
                linkSecret: options.linkSecret,
                schemas: Object.entries(options.schemas).reduce((prev, [id, object]) => {
                    const objectHandle = object instanceof Schema_1.Schema ? object.handle : (0, utils_1.pushToArray)(Schema_1.Schema.fromJson(object).handle, objectHandles);
                    prev[id] = objectHandle;
                    return prev;
                }, {}),
                credentialDefinitions: Object.entries(options.credentialDefinitions).reduce((prev, [id, object]) => {
                    const objectHandle = object instanceof CredentialDefinition_1.CredentialDefinition
                        ? object.handle
                        : (0, utils_1.pushToArray)(CredentialDefinition_1.CredentialDefinition.fromJson(object).handle, objectHandles);
                    prev[id] = objectHandle;
                    return prev;
                }, {}),
            }).handle;
        }
        finally {
            objectHandles.forEach((handle) => handle.clear());
        }
        return new Presentation(presentationHandle);
    }
    static fromJson(json) {
        return new Presentation(register_1.anoncreds.presentationFromJson({ json: JSON.stringify(json) }).handle);
    }
    verify(options) {
        var _a;
        const schemas = Object.values(options.schemas);
        const schemaIds = Object.keys(options.schemas);
        const credentialDefinitions = Object.values(options.credentialDefinitions);
        const credentialDefinitionIds = Object.keys(options.credentialDefinitions);
        const revocationRegistryDefinitions = options.revocationRegistryDefinitions
            ? Object.values(options.revocationRegistryDefinitions)
            : undefined;
        const revocationRegistryDefinitionIds = options.revocationRegistryDefinitions
            ? Object.keys(options.revocationRegistryDefinitions)
            : undefined;
        let verified;
        const objectHandles = [];
        try {
            const presentationRequest = options.presentationRequest instanceof PresentationRequest_1.PresentationRequest
                ? options.presentationRequest.handle
                : (0, utils_1.pushToArray)(PresentationRequest_1.PresentationRequest.fromJson(options.presentationRequest).handle, objectHandles);
            verified = register_1.anoncreds.verifyPresentation({
                presentation: this.handle,
                presentationRequest,
                schemas: schemas.map((o) => o instanceof Schema_1.Schema ? o.handle : (0, utils_1.pushToArray)(Schema_1.Schema.fromJson(o).handle, objectHandles)),
                schemaIds,
                credentialDefinitions: credentialDefinitions.map((o) => o instanceof CredentialDefinition_1.CredentialDefinition
                    ? o.handle
                    : (0, utils_1.pushToArray)(CredentialDefinition_1.CredentialDefinition.fromJson(o).handle, objectHandles)),
                credentialDefinitionIds,
                revocationRegistryDefinitions: revocationRegistryDefinitions === null || revocationRegistryDefinitions === void 0 ? void 0 : revocationRegistryDefinitions.map((o) => o instanceof RevocationRegistryDefinition_1.RevocationRegistryDefinition
                    ? o.handle
                    : (0, utils_1.pushToArray)(RevocationRegistryDefinition_1.RevocationRegistryDefinition.fromJson(o).handle, objectHandles)),
                revocationRegistryDefinitionIds,
                revocationStatusLists: (_a = options.revocationStatusLists) === null || _a === void 0 ? void 0 : _a.map((o) => o instanceof RevocationStatusList_1.RevocationStatusList
                    ? o.handle
                    : (0, utils_1.pushToArray)(RevocationStatusList_1.RevocationStatusList.fromJson(o).handle, objectHandles)),
                nonRevokedIntervalOverrides: options.nonRevokedIntervalOverrides,
            });
        }
        finally {
            objectHandles.forEach((handle) => handle.clear());
        }
        return verified;
    }
}
exports.Presentation = Presentation;
//# sourceMappingURL=Presentation.js.map