"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EcdhEs = void 0;
const ariesAskar_1 = require("../ariesAskar");
const Jwk_1 = require("./Jwk");
const Key_1 = require("./Key");
// Tests
class EcdhEs {
    constructor({ apv, apu, algId }) {
        this.algId = algId;
        this.apu = apu;
        this.apv = apv;
    }
    deriveKey({ encAlg, ephemeralKey, recipientKey, receive, }) {
        return new Key_1.Key(ariesAskar_1.ariesAskar.keyDeriveEcdhEs({
            algId: this.algId,
            receive,
            apv: this.apv,
            apu: this.apu,
            algorithm: encAlg,
            ephemeralKey,
            recipientKey,
        }));
    }
    encryptDirect({ encAlg, recipientKey, ephemeralKey, message, aad, nonce, }) {
        const eKey = ephemeralKey instanceof Jwk_1.Jwk ? Key_1.Key.fromJwk({ jwk: ephemeralKey }) : ephemeralKey;
        const rKey = recipientKey instanceof Jwk_1.Jwk ? Key_1.Key.fromJwk({ jwk: recipientKey }) : recipientKey;
        const derived = this.deriveKey({ encAlg, ephemeralKey: eKey, recipientKey: rKey, receive: false });
        const encryptedBuffer = derived.aeadEncrypt({ message, aad, nonce });
        derived.handle.free();
        return encryptedBuffer;
    }
    decryptDirect({ nonce, encAlg, recipientKey, ciphertext, ephemeralKey, tag, aad, }) {
        const eKey = ephemeralKey instanceof Jwk_1.Jwk ? Key_1.Key.fromJwk({ jwk: ephemeralKey }) : ephemeralKey;
        const rKey = recipientKey instanceof Jwk_1.Jwk ? Key_1.Key.fromJwk({ jwk: recipientKey }) : recipientKey;
        const derived = this.deriveKey({ encAlg, ephemeralKey: eKey, recipientKey: rKey, receive: true });
        const encryptedBuffer = derived.aeadDecrypt({ tag, nonce, ciphertext, aad });
        derived.handle.free();
        return encryptedBuffer;
    }
    senderWrapKey({ wrapAlg, ephemeralKey, recipientKey, cek, }) {
        const derived = this.deriveKey({ encAlg: wrapAlg, ephemeralKey, recipientKey, receive: false });
        const encryptedBuffer = derived.wrapKey({ other: cek });
        derived.handle.free();
        return encryptedBuffer;
    }
    receiverUnwrapKey({ recipientKey, wrapAlg, ephemeralKey, encAlg, ciphertext, nonce, tag, }) {
        const derived = this.deriveKey({ encAlg: wrapAlg, ephemeralKey, recipientKey, receive: true });
        const encryptedBuffer = derived.unwrapKey({ tag, nonce, ciphertext, algorithm: encAlg });
        derived.handle.free();
        return encryptedBuffer;
    }
}
exports.EcdhEs = EcdhEs;
//# sourceMappingURL=EcdhEs.js.map