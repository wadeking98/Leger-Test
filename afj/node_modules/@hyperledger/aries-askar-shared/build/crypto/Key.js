"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Key = void 0;
const buffer_1 = require("buffer");
const ariesAskar_1 = require("../ariesAskar");
const enums_1 = require("../enums");
const Jwk_1 = require("./Jwk");
class Key {
    constructor(handle) {
        this.localKeyHandle = handle;
    }
    static generate(algorithm, ephemeral = false) {
        return new Key(ariesAskar_1.ariesAskar.keyGenerate({ algorithm, ephemeral }));
    }
    static fromSeed({ method = enums_1.KeyMethod.None, algorithm, seed, }) {
        return new Key(ariesAskar_1.ariesAskar.keyFromSeed({ algorithm, method, seed }));
    }
    static fromSecretBytes(options) {
        return new Key(ariesAskar_1.ariesAskar.keyFromSecretBytes(options));
    }
    static fromPublicBytes(options) {
        return new Key(ariesAskar_1.ariesAskar.keyFromPublicBytes(options));
    }
    static fromJwk(options) {
        return new Key(ariesAskar_1.ariesAskar.keyFromJwk(options));
    }
    convertkey(options) {
        return new Key(ariesAskar_1.ariesAskar.keyConvert(Object.assign({ localKeyHandle: this.handle }, options)));
    }
    keyFromKeyExchange({ algorithm, publicKey }) {
        return new Key(ariesAskar_1.ariesAskar.keyFromKeyExchange({ skHandle: this.handle, pkHandle: publicKey.handle, algorithm }));
    }
    get handle() {
        return this.localKeyHandle;
    }
    get algorithm() {
        const alg = ariesAskar_1.ariesAskar.keyGetAlgorithm({ localKeyHandle: this.handle });
        return (0, enums_1.keyAlgFromString)(alg);
    }
    get ephemeral() {
        return Boolean(ariesAskar_1.ariesAskar.keyGetEphemeral({ localKeyHandle: this.handle }));
    }
    get publicBytes() {
        return ariesAskar_1.ariesAskar.keyGetPublicBytes({ localKeyHandle: this.handle });
    }
    get secretBytes() {
        return ariesAskar_1.ariesAskar.keyGetSecretBytes({ localKeyHandle: this.handle });
    }
    get jwkPublic() {
        return Jwk_1.Jwk.fromString(ariesAskar_1.ariesAskar.keyGetJwkPublic({ localKeyHandle: this.handle, algorithm: this.algorithm }));
    }
    get jwkSecret() {
        const secretBytes = ariesAskar_1.ariesAskar.keyGetJwkSecret({ localKeyHandle: this.handle });
        return Jwk_1.Jwk.fromString(buffer_1.Buffer.from(secretBytes).toString());
    }
    get jwkThumbprint() {
        return ariesAskar_1.ariesAskar.keyGetJwkThumbprint({ localKeyHandle: this.handle, algorithm: this.algorithm });
    }
    get aeadParams() {
        return ariesAskar_1.ariesAskar.keyAeadGetParams({ localKeyHandle: this.handle });
    }
    get aeadRandomNonce() {
        return ariesAskar_1.ariesAskar.keyAeadRandomNonce({ localKeyHandle: this.handle });
    }
    aeadEncrypt(options) {
        return ariesAskar_1.ariesAskar.keyAeadEncrypt(Object.assign({ localKeyHandle: this.handle }, options));
    }
    aeadDecrypt(options) {
        return ariesAskar_1.ariesAskar.keyAeadDecrypt(Object.assign({ localKeyHandle: this.handle }, options));
    }
    signMessage(options) {
        return ariesAskar_1.ariesAskar.keySignMessage(Object.assign({ localKeyHandle: this.handle }, options));
    }
    verifySignature(options) {
        return ariesAskar_1.ariesAskar.keyVerifySignature(Object.assign({ localKeyHandle: this.handle }, options));
    }
    wrapKey({ other, nonce }) {
        return ariesAskar_1.ariesAskar.keyWrapKey({ localKeyHandle: this.handle, other: other.handle, nonce });
    }
    unwrapKey(options) {
        return new Key(ariesAskar_1.ariesAskar.keyUnwrapKey(Object.assign({ localKeyHandle: this.handle }, options)));
    }
}
exports.Key = Key;
//# sourceMappingURL=Key.js.map