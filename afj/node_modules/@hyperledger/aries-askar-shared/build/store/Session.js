"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
const buffer_1 = require("buffer");
const ariesAskar_1 = require("../ariesAskar");
const EntryOperation_1 = require("../enums/EntryOperation");
const error_1 = require("../error");
const Entry_1 = require("./Entry");
const EntryList_1 = require("./EntryList");
const KeyEntryList_1 = require("./KeyEntryList");
class Session {
    constructor({ handle, isTxn }) {
        this._handle = handle;
        this.isTxn = isTxn;
    }
    get isTransaction() {
        return this.isTxn;
    }
    get handle() {
        return this._handle;
    }
    async count({ category, tagFilter }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot count from closed session' });
        return await ariesAskar_1.ariesAskar.sessionCount({ tagFilter, category, sessionHandle: this.handle });
    }
    async fetch({ category, name, forUpdate = false, isJson, }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot fetch from a closed session' });
        const handle = await ariesAskar_1.ariesAskar.sessionFetch({ forUpdate, name, category, sessionHandle: this.handle });
        if (!handle)
            return null;
        const entry = new Entry_1.Entry({ list: handle, position: 0 });
        const entryObject = entry.toJson(isJson);
        handle.free();
        return entryObject;
    }
    async fetchAll({ category, forUpdate = false, limit, tagFilter, isJson, }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot fetch all from a closed session' });
        const handle = await ariesAskar_1.ariesAskar.sessionFetchAll({
            forUpdate,
            limit,
            tagFilter,
            sessionHandle: this.handle,
            category,
        });
        if (!handle)
            return [];
        const entryList = new EntryList_1.EntryList({ handle });
        const entryObjects = entryList.toArray(isJson);
        entryList.handle.free();
        return entryObjects;
    }
    async insert({ category, name, expiryMs, tags, value, }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot insert with a closed session' });
        const serializedValue = typeof value === 'string' ? value : JSON.stringify(value);
        await ariesAskar_1.ariesAskar.sessionUpdate({
            value: Uint8Array.from(buffer_1.Buffer.from(serializedValue)),
            expiryMs,
            tags,
            name,
            category,
            sessionHandle: this.handle,
            operation: EntryOperation_1.EntryOperation.Insert,
        });
    }
    async replace({ category, name, expiryMs, tags, value, }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot replace with a closed session' });
        const serializedValue = typeof value === 'string' ? value : JSON.stringify(value);
        await ariesAskar_1.ariesAskar.sessionUpdate({
            value: Uint8Array.from(buffer_1.Buffer.from(serializedValue)),
            expiryMs,
            tags,
            name,
            category,
            sessionHandle: this.handle,
            operation: EntryOperation_1.EntryOperation.Replace,
        });
    }
    async remove({ category, name }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot remove with a closed session' });
        await ariesAskar_1.ariesAskar.sessionUpdate({
            name,
            category,
            sessionHandle: this.handle,
            operation: EntryOperation_1.EntryOperation.Remove,
        });
    }
    async removeAll({ category, tagFilter }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot remove all with a closed session' });
        await ariesAskar_1.ariesAskar.sessionRemoveAll({
            category,
            sessionHandle: this.handle,
            tagFilter,
        });
    }
    async insertKey({ name, key, expiryMs, metadata, tags, }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot insert a key with a closed session' });
        await ariesAskar_1.ariesAskar.sessionInsertKey({
            expiryMs,
            tags,
            metadata,
            name,
            sessionHandle: this.handle,
            localKeyHandle: key.handle,
        });
    }
    async fetchKey({ name, forUpdate = false }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot fetch a key with a closed session' });
        const handle = await ariesAskar_1.ariesAskar.sessionFetchKey({ forUpdate, name, sessionHandle: this.handle });
        if (!handle)
            return null;
        const keyEntryList = new KeyEntryList_1.KeyEntryList({ handle });
        const keyEntryObject = keyEntryList.getEntryByIndex(0).toJson();
        keyEntryList.handle.free();
        return keyEntryObject;
    }
    async fetchAllKeys({ forUpdate = false, algorithm, limit, tagFilter, thumbprint, }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot fetch all keys with a closed session' });
        const handle = await ariesAskar_1.ariesAskar.sessionFetchAllKeys({
            forUpdate,
            limit,
            tagFilter,
            thumbprint,
            algorithm,
            sessionHandle: this.handle,
        });
        if (!handle)
            return [];
        const keyEntryList = new KeyEntryList_1.KeyEntryList({ handle });
        const keyEntryObjects = keyEntryList.toArray();
        keyEntryList.handle.free();
        return keyEntryObjects;
    }
    async updateKey({ name, expiryMs, metadata, tags, }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot update a key with a closed session' });
        await ariesAskar_1.ariesAskar.sessionUpdateKey({ expiryMs, tags, metadata, name, sessionHandle: this.handle });
    }
    async removeKey({ name }) {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot remove a key with a closed session' });
        await ariesAskar_1.ariesAskar.sessionRemoveKey({ name, sessionHandle: this.handle });
    }
    /**
     * @note also closes the session
     */
    async commit() {
        if (!this.isTxn)
            throw error_1.AriesAskarError.customError({ message: 'Session is not a transaction' });
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot commit a closed session' });
        await this.handle.close(true);
        this._handle = undefined;
    }
    async rollback() {
        if (!this.isTxn)
            throw error_1.AriesAskarError.customError({ message: 'Session is not a transaction' });
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot rollback a closed session' });
        await this.handle.close(false);
        this._handle = undefined;
    }
    async close() {
        if (!this.handle)
            throw error_1.AriesAskarError.customError({ message: 'Cannot close a closed session' });
        await this.handle.close(false);
        this._handle = undefined;
    }
}
exports.Session = Session;
//# sourceMappingURL=Session.js.map