import type { ByteBufferStruct } from './structures';
import type { Pointer } from '@2060.io/ref-napi';
import type { TypedArray } from 'ref-array-di';
import type { StructObject } from 'ref-struct-di';
import { ObjectHandle } from '@hyperledger/anoncreds-shared';
declare type Argument = Record<string, unknown> | Array<unknown> | Date | Uint8Array | SerializedArgument | boolean | ObjectHandle;
declare type SerializedArgument = string | number | ArrayBuffer | Buffer | StructObject<{
    count: number | string;
    data: TypedArray<string | number | null>;
}> | StructObject<{
    count: number | string;
    data: Pointer<TypedArray<string | number | null>>;
}>;
export declare type SerializedOptions<Type> = Required<{
    [Property in keyof Type]: Type[Property] extends string ? string : Type[Property] extends number ? number : Type[Property] extends boolean ? number : Type[Property] extends boolean | undefined ? number : Type[Property] extends Record<string, unknown> ? string : Type[Property] extends Array<string> ? Buffer : Type[Property] extends Array<string> | undefined ? Buffer : Type[Property] extends Array<number> ? Buffer : Type[Property] extends Array<number> | undefined ? Buffer : Type[Property] extends Date ? number : Type[Property] extends Date | undefined ? number : Type[Property] extends string | undefined ? string : Type[Property] extends number | undefined ? number : Type[Property] extends Buffer ? Buffer : Type[Property] extends ObjectHandle ? number : Type[Property] extends Array<ObjectHandle> ? Buffer : Type[Property] extends Array<ObjectHandle> | undefined ? Buffer : Type[Property] extends ObjectHandle | undefined ? number : Type[Property] extends Uint8Array ? typeof ByteBufferStruct : Type[Property] extends Uint8Array | undefined ? typeof ByteBufferStruct : Type[Property] extends Array<unknown> | undefined ? string : Type[Property] extends Record<string, unknown> | undefined ? string : unknown;
}>;
declare const serializeArguments: <T extends Record<string, Argument> = Record<string, Argument>>(args: T) => Required<{ [Property in keyof T]: T[Property] extends string ? string : T[Property] extends number ? number : T[Property] extends boolean ? number : T[Property] extends boolean | undefined ? number : T[Property] extends Record<string, unknown> ? string : T[Property] extends string[] ? Buffer : T[Property] extends string[] | undefined ? Buffer : T[Property] extends number[] ? Buffer : T[Property] extends number[] | undefined ? Buffer : T[Property] extends Date ? number : T[Property] extends Date | undefined ? number : T[Property] extends string | undefined ? string : T[Property] extends number | undefined ? number : T[Property] extends Buffer ? Buffer : T[Property] extends ObjectHandle ? number : T[Property] extends ObjectHandle[] ? Buffer : T[Property] extends ObjectHandle[] | undefined ? Buffer : T[Property] extends ObjectHandle | undefined ? number : T[Property] extends Uint8Array ? import("ref-struct-di").StructType<{
    len: import("ref-napi").Type<string | number>;
    data: import("ref-napi").Type<Pointer<string | null>>;
}> : T[Property] extends Uint8Array | undefined ? import("ref-struct-di").StructType<{
    len: import("ref-napi").Type<string | number>;
    data: import("ref-napi").Type<Pointer<string | null>>;
}> : T[Property] extends unknown[] | undefined ? string : T[Property] extends Record<string, unknown> | undefined ? string : unknown; }>;
export { serializeArguments };
