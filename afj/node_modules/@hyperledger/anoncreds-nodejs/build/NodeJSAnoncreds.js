"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeJSAnoncreds = void 0;
const anoncreds_shared_1 = require("@hyperledger/anoncreds-shared");
const util_1 = require("util");
const ffi_1 = require("./ffi");
const library_1 = require("./library");
function handleReturnPointer(returnValue, cleanupCallback) {
    if (returnValue.address() === 0) {
        throw anoncreds_shared_1.AnoncredsError.customError({ message: 'Unexpected null pointer' });
    }
    const ret = returnValue.deref();
    if (cleanupCallback)
        cleanupCallback(returnValue);
    return ret;
}
class NodeJSAnoncreds {
    handleError() {
        const nativeError = (0, ffi_1.allocateStringBuffer)();
        (0, library_1.getNativeAnoncreds)().anoncreds_get_current_error(nativeError);
        const anoncredsErrorObject = JSON.parse(nativeError.deref());
        if (anoncredsErrorObject.code === 0)
            return;
        throw new anoncreds_shared_1.AnoncredsError(anoncredsErrorObject);
    }
    get nativeAnoncreds() {
        return (0, library_1.getNativeAnoncreds)();
    }
    generateNonce() {
        const ret = (0, ffi_1.allocateStringBuffer)();
        this.nativeAnoncreds.anoncreds_generate_nonce(ret);
        this.handleError();
        return handleReturnPointer(ret, this.nativeAnoncreds.anoncreds_string_free);
    }
    createSchema(options) {
        const { name, version, issuerId, attributeNames } = (0, ffi_1.serializeArguments)(options);
        const ret = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_create_schema(name, version, issuerId, attributeNames, ret);
        this.handleError();
        return new anoncreds_shared_1.ObjectHandle(handleReturnPointer(ret));
    }
    revocationRegistryDefinitionGetAttribute(options) {
        const { objectHandle, name } = (0, ffi_1.serializeArguments)(options);
        const ret = (0, ffi_1.allocateStringBuffer)();
        this.nativeAnoncreds.anoncreds_revocation_registry_definition_get_attribute(objectHandle, name, ret);
        this.handleError();
        return handleReturnPointer(ret, this.nativeAnoncreds.anoncreds_string_free);
    }
    credentialGetAttribute(options) {
        const { objectHandle, name } = (0, ffi_1.serializeArguments)(options);
        const ret = (0, ffi_1.allocateStringBuffer)();
        this.nativeAnoncreds.anoncreds_credential_get_attribute(objectHandle, name, ret);
        this.handleError();
        return handleReturnPointer(ret, this.nativeAnoncreds.anoncreds_string_free);
    }
    createCredentialDefinition(options) {
        const { schemaId, issuerId, schema, tag, signatureType, supportRevocation } = (0, ffi_1.serializeArguments)(options);
        const credentialDefinitionPtr = (0, ffi_1.allocatePointer)();
        const credentialDefinitionPrivatePtr = (0, ffi_1.allocatePointer)();
        const keyCorrectnessProofPtr = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_create_credential_definition(schemaId, schema, tag, issuerId, signatureType, supportRevocation, credentialDefinitionPtr, credentialDefinitionPrivatePtr, keyCorrectnessProofPtr);
        this.handleError();
        return {
            credentialDefinition: new anoncreds_shared_1.ObjectHandle(handleReturnPointer(credentialDefinitionPtr)),
            credentialDefinitionPrivate: new anoncreds_shared_1.ObjectHandle(handleReturnPointer(credentialDefinitionPrivatePtr)),
            keyCorrectnessProof: new anoncreds_shared_1.ObjectHandle(handleReturnPointer(keyCorrectnessProofPtr)),
        };
    }
    createCredential(options) {
        var _a;
        const { credentialDefinition, credentialDefinitionPrivate, credentialOffer, credentialRequest } = (0, ffi_1.serializeArguments)(options);
        const attributeNames = (0, ffi_1.StringListStruct)({
            count: Object.keys(options.attributeRawValues).length,
            data: Object.keys(options.attributeRawValues),
        });
        const attributeRawValues = (0, ffi_1.StringListStruct)({
            count: Object.keys(options.attributeRawValues).length,
            data: Object.values(options.attributeRawValues),
        });
        const attributeEncodedValues = options.attributeEncodedValues
            ? (0, ffi_1.StringListStruct)({
                count: Object.keys(options.attributeEncodedValues).length,
                data: Object.values(options.attributeEncodedValues),
            })
            : undefined;
        let revocationConfiguration;
        if (options.revocationConfiguration) {
            const { revocationRegistryDefinition, revocationRegistryDefinitionPrivate, revocationStatusList, registryIndex } = (0, ffi_1.serializeArguments)(options.revocationConfiguration);
            revocationConfiguration = (0, ffi_1.CredRevInfoStruct)({
                reg_def: revocationRegistryDefinition,
                reg_def_private: revocationRegistryDefinitionPrivate,
                status_list: revocationStatusList,
                reg_idx: registryIndex,
            });
        }
        const credentialPtr = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_create_credential(credentialDefinition, credentialDefinitionPrivate, credentialOffer, credentialRequest, attributeNames, attributeRawValues, attributeEncodedValues, (_a = revocationConfiguration === null || revocationConfiguration === void 0 ? void 0 : revocationConfiguration.ref().address()) !== null && _a !== void 0 ? _a : 0, credentialPtr);
        this.handleError();
        return new anoncreds_shared_1.ObjectHandle(handleReturnPointer(credentialPtr));
    }
    encodeCredentialAttributes(options) {
        const { attributeRawValues } = (0, ffi_1.serializeArguments)(options);
        const ret = (0, ffi_1.allocateStringBuffer)();
        this.nativeAnoncreds.anoncreds_encode_credential_attributes(attributeRawValues, ret);
        this.handleError();
        const result = handleReturnPointer(ret, this.nativeAnoncreds.anoncreds_string_free);
        return result.split(',');
    }
    processCredential(options) {
        var _a, _b;
        const { credential, credentialRequestMetadata, linkSecret, credentialDefinition } = (0, ffi_1.serializeArguments)(options);
        const ret = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_process_credential(credential, credentialRequestMetadata, linkSecret, credentialDefinition, (_b = (_a = options.revocationRegistryDefinition) === null || _a === void 0 ? void 0 : _a.handle) !== null && _b !== void 0 ? _b : 0, ret);
        this.handleError();
        return new anoncreds_shared_1.ObjectHandle(handleReturnPointer(ret));
    }
    createCredentialOffer(options) {
        const { schemaId, credentialDefinitionId, keyCorrectnessProof } = (0, ffi_1.serializeArguments)(options);
        const ret = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_create_credential_offer(schemaId, credentialDefinitionId, keyCorrectnessProof, ret);
        this.handleError();
        return new anoncreds_shared_1.ObjectHandle(handleReturnPointer(ret));
    }
    createCredentialRequest(options) {
        const { entropy, proverDid, credentialDefinition, linkSecret, linkSecretId, credentialOffer } = (0, ffi_1.serializeArguments)(options);
        const credentialRequestPtr = (0, ffi_1.allocatePointer)();
        const credentialRequestMetadataPtr = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_create_credential_request(entropy, proverDid, credentialDefinition, linkSecret, linkSecretId, credentialOffer, credentialRequestPtr, credentialRequestMetadataPtr);
        this.handleError();
        return {
            credentialRequest: new anoncreds_shared_1.ObjectHandle(handleReturnPointer(credentialRequestPtr)),
            credentialRequestMetadata: new anoncreds_shared_1.ObjectHandle(handleReturnPointer(credentialRequestMetadataPtr)),
        };
    }
    createLinkSecret() {
        const ret = (0, ffi_1.allocateStringBuffer)();
        this.nativeAnoncreds.anoncreds_create_link_secret(ret);
        this.handleError();
        return handleReturnPointer(ret, this.nativeAnoncreds.anoncreds_string_free);
    }
    createPresentation(options) {
        const { presentationRequest, linkSecret } = (0, ffi_1.serializeArguments)(options);
        const credentialEntries = options.credentials.map((value) => {
            var _a, _b, _c;
            return (0, ffi_1.CredentialEntryStruct)({
                credential: value.credential.handle,
                timestamp: (_a = value.timestamp) !== null && _a !== void 0 ? _a : -1,
                rev_state: (_c = (_b = value.revocationState) === null || _b === void 0 ? void 0 : _b.handle) !== null && _c !== void 0 ? _c : 0,
            });
        });
        const credentialEntryList = (0, ffi_1.CredentialEntryListStruct)({
            count: credentialEntries.length,
            data: credentialEntries,
        });
        const credentialProves = options.credentialsProve.map((value) => {
            const { entryIndex: entry_idx, isPredicate: is_predicate, reveal, referent } = (0, ffi_1.serializeArguments)(value);
            return (0, ffi_1.CredentialProveStruct)({ entry_idx, referent, is_predicate, reveal });
        });
        const credentialProveList = (0, ffi_1.CredentialProveListStruct)({
            count: credentialProves.length,
            data: credentialProves,
        });
        const selfAttestNames = (0, ffi_1.StringListStruct)({
            count: Object.keys(options.selfAttest).length,
            data: Object.keys(options.selfAttest),
        });
        const selfAttestValues = (0, ffi_1.StringListStruct)({
            count: Object.values(options.selfAttest).length,
            data: Object.values(options.selfAttest),
        });
        const schemaKeys = Object.keys(options.schemas);
        const schemaIds = (0, ffi_1.StringListStruct)({
            count: schemaKeys.length,
            data: schemaKeys,
        });
        const schemaValues = Object.values(options.schemas);
        const schemas = (0, ffi_1.ObjectHandleListStruct)({
            count: schemaValues.length,
            data: (0, ffi_1.ObjectHandleArray)(schemaValues.map((o) => o.handle)),
        });
        const credentialDefinitionKeys = Object.keys(options.credentialDefinitions);
        const credentialDefinitionIds = (0, ffi_1.StringListStruct)({
            count: credentialDefinitionKeys.length,
            data: credentialDefinitionKeys,
        });
        const credentialDefinitionValues = Object.values(options.credentialDefinitions);
        const credentialDefinitions = (0, ffi_1.ObjectHandleListStruct)({
            count: credentialDefinitionValues.length,
            data: (0, ffi_1.ObjectHandleArray)(credentialDefinitionValues.map((o) => o.handle)),
        });
        const ret = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_create_presentation(presentationRequest, credentialEntryList, credentialProveList, selfAttestNames, selfAttestValues, linkSecret, schemas, schemaIds, credentialDefinitions, credentialDefinitionIds, ret);
        this.handleError();
        return new anoncreds_shared_1.ObjectHandle(handleReturnPointer(ret));
    }
    verifyPresentation(options) {
        var _a, _b, _c;
        const { presentation, presentationRequest, schemas, credentialDefinitions, revocationRegistryDefinitions, revocationStatusLists, revocationRegistryDefinitionIds, schemaIds, credentialDefinitionIds, } = (0, ffi_1.serializeArguments)(options);
        const nativeNonRevokedIntervalOverrides = (_a = options.nonRevokedIntervalOverrides) === null || _a === void 0 ? void 0 : _a.map((value) => {
            const { requestedFromTimestamp, revocationRegistryDefinitionId, overrideRevocationStatusListTimestamp } = (0, ffi_1.serializeArguments)(value);
            return (0, ffi_1.NonRevokedIntervalOverrideStruct)({
                rev_reg_def_id: revocationRegistryDefinitionId,
                requested_from_ts: requestedFromTimestamp,
                override_rev_status_list_ts: overrideRevocationStatusListTimestamp,
            });
        });
        const nonRevokedIntervalOverrideList = (0, ffi_1.NonRevokedIntervalOverrideListStruct)({
            count: (_c = (_b = options.nonRevokedIntervalOverrides) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0,
            data: nativeNonRevokedIntervalOverrides,
        });
        const ret = (0, ffi_1.allocateInt8Buffer)();
        this.nativeAnoncreds.anoncreds_verify_presentation(presentation, presentationRequest, schemas, schemaIds, credentialDefinitions, credentialDefinitionIds, revocationRegistryDefinitions, revocationRegistryDefinitionIds, revocationStatusLists, nonRevokedIntervalOverrideList, ret);
        this.handleError();
        return Boolean(handleReturnPointer(ret));
    }
    createRevocationStatusList(options) {
        const { credentialDefinition, revocationRegistryDefinitionId, revocationRegistryDefinition, revocationRegistryDefinitionPrivate, issuerId, issuanceByDefault, timestamp, } = (0, ffi_1.serializeArguments)(options);
        const ret = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_create_revocation_status_list(credentialDefinition, revocationRegistryDefinitionId, revocationRegistryDefinition, revocationRegistryDefinitionPrivate, issuerId, issuanceByDefault, timestamp !== null && timestamp !== void 0 ? timestamp : -1, ret);
        this.handleError();
        return new anoncreds_shared_1.ObjectHandle(handleReturnPointer(ret));
    }
    updateRevocationStatusListTimestampOnly(options) {
        const { currentRevocationStatusList, timestamp } = (0, ffi_1.serializeArguments)(options);
        const ret = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_update_revocation_status_list_timestamp_only(timestamp, currentRevocationStatusList, ret);
        this.handleError();
        return new anoncreds_shared_1.ObjectHandle(handleReturnPointer(ret));
    }
    updateRevocationStatusList(options) {
        const { credentialDefinition, revocationRegistryDefinition, revocationRegistryDefinitionPrivate, currentRevocationStatusList, issued, revoked, timestamp, } = (0, ffi_1.serializeArguments)(options);
        const ret = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_update_revocation_status_list(credentialDefinition, revocationRegistryDefinition, revocationRegistryDefinitionPrivate, currentRevocationStatusList, issued, revoked, timestamp !== null && timestamp !== void 0 ? timestamp : -1, ret);
        this.handleError();
        return new anoncreds_shared_1.ObjectHandle(handleReturnPointer(ret));
    }
    createRevocationRegistryDefinition(options) {
        const { credentialDefinition, credentialDefinitionId, tag, revocationRegistryType, issuerId, maximumCredentialNumber, tailsDirectoryPath, } = (0, ffi_1.serializeArguments)(options);
        const revocationRegistryDefinitionPtr = (0, ffi_1.allocatePointer)();
        const revocationRegistryDefinitionPrivate = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_create_revocation_registry_def(credentialDefinition, credentialDefinitionId, issuerId, tag, revocationRegistryType, maximumCredentialNumber, tailsDirectoryPath, revocationRegistryDefinitionPtr, revocationRegistryDefinitionPrivate);
        this.handleError();
        return {
            revocationRegistryDefinition: new anoncreds_shared_1.ObjectHandle(handleReturnPointer(revocationRegistryDefinitionPtr)),
            revocationRegistryDefinitionPrivate: new anoncreds_shared_1.ObjectHandle(handleReturnPointer(revocationRegistryDefinitionPrivate)),
        };
    }
    createOrUpdateRevocationState(options) {
        var _a, _b;
        const { revocationRegistryDefinition, revocationStatusList, revocationRegistryIndex, tailsPath } = (0, ffi_1.serializeArguments)(options);
        const oldRevocationState = (_a = options.oldRevocationState) !== null && _a !== void 0 ? _a : new anoncreds_shared_1.ObjectHandle(0);
        const oldRevocationStatusList = (_b = options.oldRevocationStatusList) !== null && _b !== void 0 ? _b : new anoncreds_shared_1.ObjectHandle(0);
        const ret = (0, ffi_1.allocatePointer)();
        this.nativeAnoncreds.anoncreds_create_or_update_revocation_state(revocationRegistryDefinition, revocationStatusList, revocationRegistryIndex, tailsPath, oldRevocationState.handle, oldRevocationStatusList.handle, ret);
        this.handleError();
        return new anoncreds_shared_1.ObjectHandle(handleReturnPointer(ret));
    }
    version() {
        return this.nativeAnoncreds.anoncreds_version();
    }
    setDefaultLogger() {
        this.nativeAnoncreds.anoncreds_set_default_logger();
        this.handleError();
    }
    // This should be called when a function returns a non-zero code
    getCurrentError() {
        const ret = (0, ffi_1.allocateStringBuffer)();
        this.nativeAnoncreds.anoncreds_get_current_error(ret);
        this.handleError();
        return handleReturnPointer(ret, this.nativeAnoncreds.anoncreds_string_free);
    }
    objectFromJson(method, options) {
        const ret = (0, ffi_1.allocatePointer)();
        const byteBuffer = anoncreds_shared_1.ByteBuffer.fromUint8Array(new util_1.TextEncoder().encode(options.json));
        this.handleError();
        method(byteBuffer, ret);
        return new anoncreds_shared_1.ObjectHandle(handleReturnPointer(ret));
    }
    presentationRequestFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_presentation_request_from_json, options);
    }
    credentialRequestFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_credential_request_from_json, options);
    }
    credentialRequestMetadataFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_credential_request_metadata_from_json, options);
    }
    revocationRegistryDefinitionFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_revocation_registry_definition_from_json, options);
    }
    revocationRegistryFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_revocation_registry_from_json, options);
    }
    revocationStatusListFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_revocation_status_list_from_json, options);
    }
    revocationStateFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_revocation_state_from_json, options);
    }
    presentationFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_presentation_from_json, options);
    }
    credentialOfferFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_credential_offer_from_json, options);
    }
    schemaFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_schema_from_json, options);
    }
    credentialFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_credential_from_json, options);
    }
    revocationRegistryDefinitionPrivateFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_revocation_registry_definition_private_from_json, options);
    }
    credentialDefinitionFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_credential_definition_from_json, options);
    }
    credentialDefinitionPrivateFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_credential_definition_private_from_json, options);
    }
    keyCorrectnessProofFromJson(options) {
        return this.objectFromJson(this.nativeAnoncreds.anoncreds_key_correctness_proof_from_json, options);
    }
    getJson(options) {
        const ret = (0, ffi_1.allocateByteBuffer)();
        const { objectHandle } = (0, ffi_1.serializeArguments)(options);
        this.nativeAnoncreds.anoncreds_object_get_json(objectHandle, ret);
        this.handleError();
        const returnValue = handleReturnPointer(ret);
        const jsonAsArray = new Uint8Array((0, ffi_1.byteBufferToBuffer)(returnValue));
        const output = new util_1.TextDecoder().decode(jsonAsArray);
        this.nativeAnoncreds.anoncreds_buffer_free(returnValue.data);
        return output;
    }
    getTypeName(options) {
        const { objectHandle } = (0, ffi_1.serializeArguments)(options);
        const ret = (0, ffi_1.allocateStringBuffer)();
        this.nativeAnoncreds.anoncreds_object_get_type_name(objectHandle, ret);
        this.handleError();
        return handleReturnPointer(ret, this.nativeAnoncreds.anoncreds_string_free);
    }
    objectFree(options) {
        this.nativeAnoncreds.anoncreds_object_free(options.objectHandle.handle);
        this.handleError();
    }
}
exports.NodeJSAnoncreds = NodeJSAnoncreds;
//# sourceMappingURL=NodeJSAnoncreds.js.map