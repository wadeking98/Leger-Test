"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnonCredsRsHolderService = void 0;
const anoncreds_1 = require("@aries-framework/anoncreds");
const core_1 = require("@aries-framework/core");
const anoncreds_shared_1 = require("@hyperledger/anoncreds-shared");
const AnonCredsRsModuleConfig_1 = require("../AnonCredsRsModuleConfig");
const AnonCredsRsError_1 = require("../errors/AnonCredsRsError");
let AnonCredsRsHolderService = class AnonCredsRsHolderService {
    async createLinkSecret(agentContext, options) {
        var _a;
        return {
            linkSecretId: (_a = options === null || options === void 0 ? void 0 : options.linkSecretId) !== null && _a !== void 0 ? _a : core_1.utils.uuid(),
            linkSecretValue: anoncreds_shared_1.LinkSecret.create(),
        };
    }
    async createProof(agentContext, options) {
        const { credentialDefinitions, proofRequest, selectedCredentials, schemas } = options;
        let presentation;
        try {
            const rsCredentialDefinitions = {};
            for (const credDefId in credentialDefinitions) {
                rsCredentialDefinitions[credDefId] = credentialDefinitions[credDefId];
            }
            const rsSchemas = {};
            for (const schemaId in schemas) {
                rsSchemas[schemaId] = schemas[schemaId];
            }
            const credentialRepository = agentContext.dependencyManager.resolve(anoncreds_1.AnonCredsCredentialRepository);
            // Cache retrieved credentials in order to minimize storage calls
            const retrievedCredentials = new Map();
            const credentialEntryFromAttribute = async (attribute) => {
                let credentialRecord = retrievedCredentials.get(attribute.credentialId);
                if (!credentialRecord) {
                    credentialRecord = await credentialRepository.getByCredentialId(agentContext, attribute.credentialId);
                    retrievedCredentials.set(attribute.credentialId, credentialRecord);
                }
                const revocationRegistryDefinitionId = credentialRecord.credential.rev_reg_id;
                const revocationRegistryIndex = credentialRecord.credentialRevocationId;
                // TODO: Check if credential has a revocation registry id (check response from anoncreds-rs API, as it is
                // sending back a mandatory string in Credential.revocationRegistryId)
                const timestamp = attribute.timestamp;
                let revocationState;
                let revocationRegistryDefinition;
                try {
                    if (timestamp && revocationRegistryIndex && revocationRegistryDefinitionId) {
                        if (!options.revocationRegistries[revocationRegistryDefinitionId]) {
                            throw new AnonCredsRsError_1.AnonCredsRsError(`Revocation Registry ${revocationRegistryDefinitionId} not found`);
                        }
                        const { definition, revocationStatusLists, tailsFilePath } = options.revocationRegistries[revocationRegistryDefinitionId];
                        // Extract revocation status list for the given timestamp
                        const revocationStatusList = revocationStatusLists[timestamp];
                        if (!revocationStatusList) {
                            throw new core_1.AriesFrameworkError(`Revocation status list for revocation registry ${revocationRegistryDefinitionId} and timestamp ${timestamp} not found in revocation status lists. All revocation status lists must be present.`);
                        }
                        revocationRegistryDefinition = anoncreds_shared_1.RevocationRegistryDefinition.fromJson(definition);
                        revocationState = anoncreds_shared_1.CredentialRevocationState.create({
                            revocationRegistryIndex: Number(revocationRegistryIndex),
                            revocationRegistryDefinition,
                            tailsPath: tailsFilePath,
                            revocationStatusList: anoncreds_shared_1.RevocationStatusList.fromJson(revocationStatusList),
                        });
                    }
                    return {
                        linkSecretId: credentialRecord.linkSecretId,
                        credentialEntry: {
                            credential: credentialRecord.credential,
                            revocationState: revocationState === null || revocationState === void 0 ? void 0 : revocationState.toJson(),
                            timestamp,
                        },
                    };
                }
                finally {
                    revocationState === null || revocationState === void 0 ? void 0 : revocationState.handle.clear();
                    revocationRegistryDefinition === null || revocationRegistryDefinition === void 0 ? void 0 : revocationRegistryDefinition.handle.clear();
                }
            };
            const credentialsProve = [];
            const credentials = [];
            let entryIndex = 0;
            for (const referent in selectedCredentials.attributes) {
                const attribute = selectedCredentials.attributes[referent];
                credentials.push(await credentialEntryFromAttribute(attribute));
                credentialsProve.push({ entryIndex, isPredicate: false, referent, reveal: attribute.revealed });
                entryIndex = entryIndex + 1;
            }
            for (const referent in selectedCredentials.predicates) {
                const predicate = selectedCredentials.predicates[referent];
                credentials.push(await credentialEntryFromAttribute(predicate));
                credentialsProve.push({ entryIndex, isPredicate: true, referent, reveal: true });
                entryIndex = entryIndex + 1;
            }
            // Get all requested credentials and take linkSecret. If it's not the same for every credential, throw error
            const linkSecretsMatch = credentials.every((item) => item.linkSecretId === credentials[0].linkSecretId);
            if (!linkSecretsMatch) {
                throw new AnonCredsRsError_1.AnonCredsRsError('All credentials in a Proof should have been issued using the same Link Secret');
            }
            const linkSecretRecord = await agentContext.dependencyManager
                .resolve(anoncreds_1.AnonCredsLinkSecretRepository)
                .getByLinkSecretId(agentContext, credentials[0].linkSecretId);
            if (!linkSecretRecord.value) {
                throw new AnonCredsRsError_1.AnonCredsRsError('Link Secret value not stored');
            }
            presentation = anoncreds_shared_1.Presentation.create({
                credentialDefinitions: rsCredentialDefinitions,
                schemas: rsSchemas,
                presentationRequest: proofRequest,
                credentials: credentials.map((entry) => entry.credentialEntry),
                credentialsProve,
                selfAttest: selectedCredentials.selfAttestedAttributes,
                linkSecret: linkSecretRecord.value,
            });
            return presentation.toJson();
        }
        finally {
            presentation === null || presentation === void 0 ? void 0 : presentation.handle.clear();
        }
    }
    async createCredentialRequest(agentContext, options) {
        const { useLegacyProverDid, credentialDefinition, credentialOffer } = options;
        let createReturnObj;
        try {
            const linkSecretRepository = agentContext.dependencyManager.resolve(anoncreds_1.AnonCredsLinkSecretRepository);
            // If a link secret is specified, use it. Otherwise, attempt to use default link secret
            let linkSecretRecord = options.linkSecretId
                ? await linkSecretRepository.getByLinkSecretId(agentContext, options.linkSecretId)
                : await linkSecretRepository.findDefault(agentContext);
            // No default link secret. Automatically create one if set on module config
            if (!linkSecretRecord) {
                const moduleConfig = agentContext.dependencyManager.resolve(AnonCredsRsModuleConfig_1.AnonCredsRsModuleConfig);
                if (!moduleConfig.autoCreateLinkSecret) {
                    throw new AnonCredsRsError_1.AnonCredsRsError('No link secret provided to createCredentialRequest and no default link secret has been found');
                }
                const { linkSecretId, linkSecretValue } = await this.createLinkSecret(agentContext, {});
                linkSecretRecord = await (0, anoncreds_1.storeLinkSecret)(agentContext, { linkSecretId, linkSecretValue, setAsDefault: true });
            }
            if (!linkSecretRecord.value) {
                throw new AnonCredsRsError_1.AnonCredsRsError('Link Secret value not stored');
            }
            const isLegacyIdentifier = credentialOffer.cred_def_id.match(anoncreds_1.unqualifiedCredentialDefinitionIdRegex);
            if (!isLegacyIdentifier && useLegacyProverDid) {
                throw new core_1.AriesFrameworkError('Cannot use legacy prover_did with non-legacy identifiers');
            }
            createReturnObj = anoncreds_shared_1.CredentialRequest.create({
                entropy: !useLegacyProverDid || !isLegacyIdentifier ? anoncreds_shared_1.anoncreds.generateNonce() : undefined,
                proverDid: useLegacyProverDid
                    ? core_1.TypedArrayEncoder.toBase58(core_1.TypedArrayEncoder.fromString(anoncreds_shared_1.anoncreds.generateNonce().slice(0, 16)))
                    : undefined,
                credentialDefinition: credentialDefinition,
                credentialOffer: credentialOffer,
                linkSecret: linkSecretRecord.value,
                linkSecretId: linkSecretRecord.linkSecretId,
            });
            return {
                credentialRequest: createReturnObj.credentialRequest.toJson(),
                credentialRequestMetadata: createReturnObj.credentialRequestMetadata.toJson(),
            };
        }
        finally {
            createReturnObj === null || createReturnObj === void 0 ? void 0 : createReturnObj.credentialRequest.handle.clear();
            createReturnObj === null || createReturnObj === void 0 ? void 0 : createReturnObj.credentialRequestMetadata.handle.clear();
        }
    }
    async storeCredential(agentContext, options) {
        var _a, _b;
        const { credential, credentialDefinition, credentialRequestMetadata, revocationRegistry, schema } = options;
        const linkSecretRecord = await agentContext.dependencyManager
            .resolve(anoncreds_1.AnonCredsLinkSecretRepository)
            .getByLinkSecretId(agentContext, credentialRequestMetadata.link_secret_name);
        if (!linkSecretRecord.value) {
            throw new AnonCredsRsError_1.AnonCredsRsError('Link Secret value not stored');
        }
        const revocationRegistryDefinition = revocationRegistry === null || revocationRegistry === void 0 ? void 0 : revocationRegistry.definition;
        const credentialId = (_a = options.credentialId) !== null && _a !== void 0 ? _a : core_1.utils.uuid();
        let credentialObj;
        let processedCredential;
        try {
            credentialObj = anoncreds_shared_1.Credential.fromJson(credential);
            processedCredential = credentialObj.process({
                credentialDefinition: credentialDefinition,
                credentialRequestMetadata: credentialRequestMetadata,
                linkSecret: linkSecretRecord.value,
                revocationRegistryDefinition,
            });
            const credentialRepository = agentContext.dependencyManager.resolve(anoncreds_1.AnonCredsCredentialRepository);
            const methodName = agentContext.dependencyManager
                .resolve(anoncreds_1.AnonCredsRegistryService)
                .getRegistryForIdentifier(agentContext, credential.cred_def_id).methodName;
            await credentialRepository.save(agentContext, new anoncreds_1.AnonCredsCredentialRecord({
                credential: processedCredential.toJson(),
                credentialId,
                linkSecretId: linkSecretRecord.linkSecretId,
                issuerId: options.credentialDefinition.issuerId,
                schemaName: schema.name,
                schemaIssuerId: schema.issuerId,
                schemaVersion: schema.version,
                credentialRevocationId: (_b = processedCredential.revocationRegistryIndex) === null || _b === void 0 ? void 0 : _b.toString(),
                methodName,
            }));
            return credentialId;
        }
        finally {
            credentialObj === null || credentialObj === void 0 ? void 0 : credentialObj.handle.clear();
            processedCredential === null || processedCredential === void 0 ? void 0 : processedCredential.handle.clear();
        }
    }
    async getCredential(agentContext, options) {
        const credentialRecord = await agentContext.dependencyManager
            .resolve(anoncreds_1.AnonCredsCredentialRepository)
            .getByCredentialId(agentContext, options.credentialId);
        const attributes = {};
        for (const attribute in credentialRecord.credential.values) {
            attributes[attribute] = credentialRecord.credential.values[attribute].raw;
        }
        return {
            attributes,
            credentialDefinitionId: credentialRecord.credential.cred_def_id,
            credentialId: credentialRecord.credentialId,
            schemaId: credentialRecord.credential.schema_id,
            credentialRevocationId: credentialRecord.credentialRevocationId,
            revocationRegistryId: credentialRecord.credential.rev_reg_id,
            methodName: credentialRecord.methodName,
        };
    }
    async getCredentials(agentContext, options) {
        const credentialRecords = await agentContext.dependencyManager
            .resolve(anoncreds_1.AnonCredsCredentialRepository)
            .findByQuery(agentContext, {
            credentialDefinitionId: options.credentialDefinitionId,
            schemaId: options.schemaId,
            issuerId: options.issuerId,
            schemaName: options.schemaName,
            schemaVersion: options.schemaVersion,
            schemaIssuerId: options.schemaIssuerId,
            methodName: options.methodName,
        });
        return credentialRecords.map((credentialRecord) => ({
            attributes: Object.fromEntries(Object.entries(credentialRecord.credential.values).map(([key, value]) => [key, value.raw])),
            credentialDefinitionId: credentialRecord.credential.cred_def_id,
            credentialId: credentialRecord.credentialId,
            schemaId: credentialRecord.credential.schema_id,
            credentialRevocationId: credentialRecord.credentialRevocationId,
            revocationRegistryId: credentialRecord.credential.rev_reg_id,
            methodName: credentialRecord.methodName,
        }));
    }
    async deleteCredential(agentContext, credentialId) {
        const credentialRepository = agentContext.dependencyManager.resolve(anoncreds_1.AnonCredsCredentialRepository);
        const credentialRecord = await credentialRepository.getByCredentialId(agentContext, credentialId);
        await credentialRepository.delete(agentContext, credentialRecord);
    }
    async getCredentialsForProofRequest(agentContext, options) {
        var _a, _b;
        const proofRequest = options.proofRequest;
        const referent = options.attributeReferent;
        const requestedAttribute = (_a = proofRequest.requested_attributes[referent]) !== null && _a !== void 0 ? _a : proofRequest.requested_predicates[referent];
        if (!requestedAttribute) {
            throw new AnonCredsRsError_1.AnonCredsRsError(`Referent not found in proof request`);
        }
        const $and = [];
        // Make sure the attribute(s) that are requested are present using the marker tag
        const attributes = (_b = requestedAttribute.names) !== null && _b !== void 0 ? _b : [requestedAttribute.name];
        const attributeQuery = {};
        for (const attribute of attributes) {
            attributeQuery[`attr::${attribute}::marker`] = true;
        }
        $and.push(attributeQuery);
        // Add query for proof request restrictions
        if (requestedAttribute.restrictions) {
            const restrictionQuery = this.queryFromRestrictions(requestedAttribute.restrictions);
            $and.push(restrictionQuery);
        }
        // Add extra query
        // TODO: we're not really typing the extraQuery, and it will work differently based on the anoncreds implmentation
        // We should make the allowed properties more strict
        if (options.extraQuery) {
            $and.push(options.extraQuery);
        }
        const credentials = await agentContext.dependencyManager
            .resolve(anoncreds_1.AnonCredsCredentialRepository)
            .findByQuery(agentContext, {
            $and,
        });
        return credentials.map((credentialRecord) => {
            const attributes = {};
            for (const attribute in credentialRecord.credential.values) {
                attributes[attribute] = credentialRecord.credential.values[attribute].raw;
            }
            return {
                credentialInfo: {
                    attributes,
                    credentialDefinitionId: credentialRecord.credential.cred_def_id,
                    credentialId: credentialRecord.credentialId,
                    schemaId: credentialRecord.credential.schema_id,
                    credentialRevocationId: credentialRecord.credentialRevocationId,
                    revocationRegistryId: credentialRecord.credential.rev_reg_id,
                    methodName: credentialRecord.methodName,
                },
                interval: proofRequest.non_revoked,
            };
        });
    }
    queryFromRestrictions(restrictions) {
        var _a, _b;
        const query = [];
        const { restrictions: parsedRestrictions } = core_1.JsonTransformer.fromJSON({ restrictions }, anoncreds_1.AnonCredsRestrictionWrapper);
        for (const restriction of parsedRestrictions) {
            const queryElements = {};
            if (restriction.credentialDefinitionId) {
                queryElements.credentialDefinitionId = restriction.credentialDefinitionId;
            }
            if (restriction.issuerId || restriction.issuerDid) {
                queryElements.issuerId = (_a = restriction.issuerId) !== null && _a !== void 0 ? _a : restriction.issuerDid;
            }
            if (restriction.schemaId) {
                queryElements.schemaId = restriction.schemaId;
            }
            if (restriction.schemaIssuerId || restriction.schemaIssuerDid) {
                queryElements.schemaIssuerId = (_b = restriction.schemaIssuerId) !== null && _b !== void 0 ? _b : restriction.issuerDid;
            }
            if (restriction.schemaName) {
                queryElements.schemaName = restriction.schemaName;
            }
            if (restriction.schemaVersion) {
                queryElements.schemaVersion = restriction.schemaVersion;
            }
            for (const [attributeName, attributeValue] of Object.entries(restriction.attributeValues)) {
                queryElements[`attr::${attributeName}::value`] = attributeValue;
            }
            for (const [attributeName, isAvailable] of Object.entries(restriction.attributeMarkers)) {
                if (isAvailable) {
                    queryElements[`attr::${attributeName}::marker`] = isAvailable;
                }
            }
            query.push(queryElements);
        }
        return query.length === 1 ? query[0] : { $or: query };
    }
};
AnonCredsRsHolderService = __decorate([
    (0, core_1.injectable)()
], AnonCredsRsHolderService);
exports.AnonCredsRsHolderService = AnonCredsRsHolderService;
//# sourceMappingURL=AnonCredsRsHolderService.js.map