"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnonCredsRsIssuerService = void 0;
const anoncreds_1 = require("@aries-framework/anoncreds");
const core_1 = require("@aries-framework/core");
const anoncreds_shared_1 = require("@hyperledger/anoncreds-shared");
const AnonCredsRsError_1 = require("../errors/AnonCredsRsError");
let AnonCredsRsIssuerService = class AnonCredsRsIssuerService {
    async createSchema(agentContext, options) {
        const { issuerId, name, version, attrNames: attributeNames } = options;
        let schema;
        try {
            const schema = anoncreds_shared_1.Schema.create({
                issuerId,
                name,
                version,
                attributeNames,
            });
            return schema.toJson();
        }
        finally {
            schema === null || schema === void 0 ? void 0 : schema.handle.clear();
        }
    }
    async createCredentialDefinition(agentContext, options) {
        const { tag, supportRevocation, schema, issuerId, schemaId } = options;
        let createReturnObj;
        try {
            createReturnObj = anoncreds_shared_1.CredentialDefinition.create({
                schema: schema,
                issuerId,
                schemaId,
                tag,
                supportRevocation,
                signatureType: 'CL',
            });
            return {
                credentialDefinition: createReturnObj.credentialDefinition.toJson(),
                credentialDefinitionPrivate: createReturnObj.credentialDefinitionPrivate.toJson(),
                keyCorrectnessProof: createReturnObj.keyCorrectnessProof.toJson(),
            };
        }
        finally {
            createReturnObj === null || createReturnObj === void 0 ? void 0 : createReturnObj.credentialDefinition.handle.clear();
            createReturnObj === null || createReturnObj === void 0 ? void 0 : createReturnObj.credentialDefinitionPrivate.handle.clear();
            createReturnObj === null || createReturnObj === void 0 ? void 0 : createReturnObj.keyCorrectnessProof.handle.clear();
        }
    }
    async createCredentialOffer(agentContext, options) {
        const { credentialDefinitionId } = options;
        let credentialOffer;
        try {
            // The getByCredentialDefinitionId supports both qualified and unqualified identifiers, even though the
            // record is always stored using the qualified identifier.
            const credentialDefinitionRecord = await agentContext.dependencyManager
                .resolve(anoncreds_1.AnonCredsCredentialDefinitionRepository)
                .getByCredentialDefinitionId(agentContext, options.credentialDefinitionId);
            // We fetch the keyCorrectnessProof based on the credential definition record id, as the
            // credential definition id passed to this module could be unqualified, and the key correctness
            // proof is only stored using the qualified identifier.
            const keyCorrectnessProofRecord = await agentContext.dependencyManager
                .resolve(anoncreds_1.AnonCredsKeyCorrectnessProofRepository)
                .getByCredentialDefinitionId(agentContext, credentialDefinitionRecord.credentialDefinitionId);
            if (!credentialDefinitionRecord) {
                throw new AnonCredsRsError_1.AnonCredsRsError(`Credential Definition ${credentialDefinitionId} not found`);
            }
            let schemaId = credentialDefinitionRecord.credentialDefinition.schemaId;
            // if the credentialDefinitionId is not qualified, we need to transform the schemaId to also be unqualified
            if ((0, anoncreds_1.isUnqualifiedCredentialDefinitionId)(options.credentialDefinitionId)) {
                const { namespaceIdentifier, schemaName, schemaVersion } = (0, anoncreds_1.parseIndySchemaId)(schemaId);
                schemaId = (0, anoncreds_1.getUnqualifiedSchemaId)(namespaceIdentifier, schemaName, schemaVersion);
            }
            credentialOffer = anoncreds_shared_1.CredentialOffer.create({
                credentialDefinitionId,
                keyCorrectnessProof: keyCorrectnessProofRecord === null || keyCorrectnessProofRecord === void 0 ? void 0 : keyCorrectnessProofRecord.value,
                schemaId,
            });
            return credentialOffer.toJson();
        }
        finally {
            credentialOffer === null || credentialOffer === void 0 ? void 0 : credentialOffer.handle.clear();
        }
    }
    async createCredential(agentContext, options) {
        var _a;
        const { tailsFilePath, credentialOffer, credentialRequest, credentialValues, revocationRegistryId } = options;
        let credential;
        try {
            if (revocationRegistryId || tailsFilePath) {
                throw new core_1.AriesFrameworkError('Revocation not supported yet');
            }
            const attributeRawValues = {};
            const attributeEncodedValues = {};
            Object.keys(credentialValues).forEach((key) => {
                attributeRawValues[key] = credentialValues[key].raw;
                attributeEncodedValues[key] = credentialValues[key].encoded;
            });
            const credentialDefinitionRecord = await agentContext.dependencyManager
                .resolve(anoncreds_1.AnonCredsCredentialDefinitionRepository)
                .getByCredentialDefinitionId(agentContext, options.credentialRequest.cred_def_id);
            // We fetch the private record based on the cred def id from the cred def record, as the
            // credential definition id passed to this module could be unqualified, and the private record
            // is only stored using the qualified identifier.
            const credentialDefinitionPrivateRecord = await agentContext.dependencyManager
                .resolve(anoncreds_1.AnonCredsCredentialDefinitionPrivateRepository)
                .getByCredentialDefinitionId(agentContext, credentialDefinitionRecord.credentialDefinitionId);
            let credentialDefinition = credentialDefinitionRecord.credentialDefinition;
            if ((0, anoncreds_1.isUnqualifiedCredentialDefinitionId)(options.credentialRequest.cred_def_id)) {
                const { namespaceIdentifier, schemaName, schemaVersion } = (0, anoncreds_1.parseIndySchemaId)(credentialDefinition.schemaId);
                const { namespaceIdentifier: unqualifiedDid } = (0, anoncreds_1.parseIndyDid)(credentialDefinition.issuerId);
                anoncreds_1.parseIndyDid;
                credentialDefinition = Object.assign(Object.assign({}, credentialDefinition), { schemaId: (0, anoncreds_1.getUnqualifiedSchemaId)(namespaceIdentifier, schemaName, schemaVersion), issuerId: unqualifiedDid });
            }
            credential = anoncreds_shared_1.Credential.create({
                credentialDefinition: credentialDefinitionRecord.credentialDefinition,
                credentialOffer: credentialOffer,
                credentialRequest: credentialRequest,
                revocationRegistryId,
                attributeEncodedValues,
                attributeRawValues,
                credentialDefinitionPrivate: credentialDefinitionPrivateRecord.value,
            });
            return {
                credential: credential.toJson(),
                credentialRevocationId: (_a = credential.revocationRegistryIndex) === null || _a === void 0 ? void 0 : _a.toString(),
            };
        }
        finally {
            credential === null || credential === void 0 ? void 0 : credential.handle.clear();
        }
    }
};
AnonCredsRsIssuerService = __decorate([
    (0, core_1.injectable)()
], AnonCredsRsIssuerService);
exports.AnonCredsRsIssuerService = AnonCredsRsIssuerService;
//# sourceMappingURL=AnonCredsRsIssuerService.js.map